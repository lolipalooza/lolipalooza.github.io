---
thread: "Notas sobre Laravel"
id_msg: 5681
date: "2016-03-02 16:51:49"

subject: "Re:Notas sobre Laravel"
user: "yap320sorgesoureDug"

modified_time: 2016-03-02 20:08:30
modified_name: "yap320sorgesoureDug"
icon: xx



edit_reason: "pos nomas"
---
<strong><span style="font-size: 14pt;" class="bbc_size">¿Cómo crear tus propios Middlewares?</span></strong><br /><br />Ejemplo de esta lección: quiero que solo usuarios del tipo &#039;admin&#039; tengan acceso a la ruta <em>admin/users</em>, pues necesito un Middleware propio para ello.<br /><br /><ul class="bbc_list"><li><strong>Paso 1: crear el archivo del Middleware en <em>app/Http/Middleware</em></strong></li></ul>Es posible crear Middlewares a través de cónsola así como podíamos crear Models, Controllers, Migrations, entre otras weas y shingonerías jeje es neta:<br /><div class="codeheader">Código: <a href="javascript:void(0);" onclick="return smfSelectText(this);" class="codeoperation">[Seleccionar]</a></div><code class="bbc_code">php artisan make:middleware &lt;Nombre del Middleware&gt;</code>En este caso crearemos un Middleware llamado <em>IsAdmin</em>.<br /><br />Los middlewares son creados en la carpeta <em>app/Http/Middleware</em>, y tienen un método obligatorio llamado <em>handle()</em>.<br /><br /><ul class="bbc_list"><li><strong>Paso 2: registrar nuestro middleware</strong></li></ul>Y eso se hace en el archivo <em>app/Http/<strong>Kernel.php</strong></em>, en el array <em>protected $routeMiddleware</em>:<br /><div class="codeheader">Código: <a href="javascript:void(0);" onclick="return smfSelectText(this);" class="codeoperation">[Seleccionar]</a></div><code class="bbc_code">protected $routeMiddleware = [<br />&nbsp; &nbsp; ...<br /><br />&nbsp; &nbsp; &#039;is_admin&#039; =&gt; &#039;app\Http\Middleware\IsAdmin&#039;<br />];</code><br /><ul class="bbc_list"><li><strong>Paso 3: construyendo la lógica del middleware</strong></li></ul><br />En el middleware <em>IsAdmin</em>, agregamos el constructor, con su respectiva inyección de dependencias:<br /><br /><div class="quoteheader"><div class="topslice_quote">Citar</div></div><blockquote class="bbc_standard_quote">...<br /><br /><strong>use Illuminate\Contracts\Auth\Guard;</strong><br /><br />class IsAdmin {<br /><br />&nbsp; &nbsp; <strong>private $auth;<br /><br />&nbsp; &nbsp; public function __construct(Guard $auth)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; $this-&gt;auth = $auth;<br />&nbsp; &nbsp; }</strong><br /><br />&nbsp; &nbsp; ...<br />}<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />Podemos agregar en el método <em>handle()</em> la instrucción <em>dd($this-&gt;auth-&gt;user());</em>, sólo para probar, y para poner en funcionamiento nuestro middleware, nos vamos a rutas y agregamos el middleware:<br /><br /><div class="quoteheader"><div class="topslice_quote">Citar</div></div><blockquote class="bbc_standard_quote">...<br /><br />Route::group(&#91;&#039;prefix&#039; =&gt; &#039;admin&#039;, &#039;middleware&#039; =&gt; <strong>&#91;&#039;auth&#039;, &#039;is_admin&#039;]</strong>, &#039;namespace&#039; =&gt; &#039;Admin&#039;], function(){<br />&nbsp;&nbsp;&nbsp;Route::resource(&#039;users&#039;, &#039;UsersController&#039;);<br />});</blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />Noten que no solamente podemos agregar un middleware, sino varios en secuencia, para que se ejecuten uno tras otro. En este caso, al tratar de acceder a la ruta <em>admin/users</em>, primero se ejecutará el middleware de autenticación, y luego se ejecutará el nuestro que queremos que verifique si el usuario conectado es admin.<br /><br />Al final el <em>handle()</em> nos queda así:<br /><div class="codeheader">Código: <a href="javascript:void(0);" onclick="return smfSelectText(this);" class="codeoperation">[Seleccionar]</a></div><code class="bbc_code">public function handle($request, Closure $next)<br />{<br />&nbsp; &nbsp; if ($this-&gt;auth-&gt;user()-&gt;type != &#039;admin&#039;)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; $this-&gt;auth-&gt;logout();<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; if ($request-&gt;ajax())<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return response(&#039;unauthorized&#039;, 401);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return redirect()-&gt;guest(&#039;auth/login&#039;);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; return $next($request);<br />}</code><br />El cual podemos modificar de acuerdo a nuestras necesidades y a como deseemos que funcione la lógica de nuestra aplicación. Por ejemplo, si no queremos que se desloguee, que es lo que estamos haciendo, entonces eliminamos la línea de <em>$this-&gt;auth-&gt;logout()</em>.<br /><br /><strong>El problema que le dió dolores de cabeza al autor de los videotutoriales</strong><br /><br />Así tal y como está planteado el método <em>handle()</em>, con el <em>return redirect()-&gt;guest(&#039;auth/login&#039;);</em>, la lógica del funcionamiento es la siguiente:<br /><br /><ul class="bbc_list"><li>Si tratas de acceder a una url solo de acceso para admins (como por ejemplo: <em>admin/users/create</em>), y no estás logueado, el middleware primero te llevará a la ruta <em>auth/login</em>, y una vez te hayas autenticado como admin, eres llevado nuevamente a la url a la que querías acceder originalmente (admin/users/create), lo cual está bien.</li><li>Pero si haces lo mismo, con una cuenta que no es admin, es decir, accedes a la url <em>admin/users/create</em>, y en la pantalla de Login te auntenticas como un usuario común, la lógica del middleware te desconectará y te redireccionará a la ruta <em>auth/login</em>, lo cual está bien. pero si te vuelves a autenticar como el mismo usuario, la lógica del middleware te redireccionará nuevamente a <em>auth/login</em>, lo cual no parece un funcionamiento ideal.</li></ul><br />Lo que se quisiera más bien es que, una vez redirigido el usuario, tras una verificación fallida de admin, a la ruta <em>auth/login</em>, la lógica no persistiera en tratar de mandar al usuario a la ruta de <em>admin/users/create</em> indefinidamente, sino que, tras un fallo en la verificación, ante el próximo intento de autenticación, el usuario sea redirigido a la url estándar, es decir, a <em>home</em>.<br /><br />¿Cómo lograrlo?<br /><br />La línea responsable de persistir indefinidamente en redireccionar al usuario a la primera url ingresada es: <em>return redirect()-&gt;guest(&#039;auth/login&#039;);</em>, y para ser más específicos, es el método <em>guest()</em> el que almacena la url originalmente ingresada. Si reemplazamos <em>guest()</em> por <em>to()</em>, entonces se corrige el problema, ya que el método <em>to()</em> no almacena ninguna url.<br /><br /><span style="font-size: 14pt;" class="bbc_size"><strong>Usar un middleware genérico detector de tipos de usuarios</strong></span><br /><br />¿Qué sucede si ahora en lugar de admins, queremos restringir el contenido de nuestra página para otros tipos de usuarios? ¿Debemos desarrollar un middleware para cada tipo de usuario que queramos definir? No, mejor desarrollar un middleware genérico para detectar y validar el tipo de usuario que queramos.
